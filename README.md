# ⚜️ SPELLING CHALLENGE GAME ⚜️

터미널에서 실행하는 Python 스펠링 맞추기 게임입니다.  
단어를 한 글자씩 입력해 숨겨진 단어를 완성하세요.

---

## 🎮 게임 규칙
- 단어의 철자를 **한 글자씩 입력**
- 맞힌 글자는 공개됩니다
- 틀리면 기회가 줄어듭니다
- **한 단어당 기회는 6번**
- 게임을 중단하려면 `quit` 입력

---

## 🧠 게임 특징
- 단어는 **랜덤으로 출제**
- 이미 출제된 단어는 다시 나오지 않음
- 입력값 검증
- 알파벳 한 글자만 허용
- 이미 입력한 글자는 재입력 불가
- 점수 시스템 포함
- `words` 리스트에 단어를 추가하면 자동으로 문제 수 증가  

---

## ▶️ 실행 방법
터미널에서 게임 파일까지 접근한다(cd)
python3 game.py 를 터미널에 입력하면 게임 시작!



## 단어 목록 예시

```bash
words = [
    "sun",
    "apple",
    "window",
    "memory",
    "keyboard",
    "river",
    "umbrella",
    "dream",
    "mountain",
    "picture"
]
```
※ words 리스트에 단어를 추가하면
문제 수와 전체 게임 길이가 자동으로 늘어납니다.

---

## 🧱 사용 기술 & 개념

- `list` : 단어 목록, 언더바 상태 관리
- `while` : 게임 진행 조건 제어
- `if / elif / else` : 입력값 검증
- `random.choice()` : 단어 랜덤 선택
- 문자열 메서드
- `isalpha()` : 알파벳 여부 검사
- `lower()` : 대소문자 통일
- 상태 관리
- `used_letters` : 이미 입력한 알파벳 저장
- `underbar` : 정답 공개 상태 관리

## 🧠 전체 흐름 구조

### 1️⃣ 단어 목록 준비

```python
words = ["sun","apple","window", ...]
```

- 게임에 사용될 단어 리스트
- 단어 길이가 다양해서 힌트로 활용 가능

---

### 2️⃣ 중복 없는 랜덤 출제

```python
remaining_words = words.copy()
word = random.choice(remaining_words)
remaining_words.remove(word)
```

- `remaining_words`를 따로 만들어 **이미 나온 문제 제거**
- 랜덤이지만 **같은 단어는 다시 나오지 않음**
- 모든 단어를 풀면 게임 자동 종료

👉 단순 `random.choice()`만 쓰면 중복이 생겨서 이 구조를 선택함

---

### 3️⃣ 단어 상태 관리 (언더바)

```python
underbar = ['_'] *len(word)
```

- 단어 길이만큼 `_` 생성
- 맞춘 알파벳만 해당 위치에 채워 넣음
- `'_’ in underbar` 여부로 문제 종료 판단

---

### 4️⃣ 입력 검증 로직

```python
if userInput =='quit':
    exit()

iflen(userInput) !=1ornot userInput.isalpha():
continue

if userInputin used_letters:
continue
```

입력은 반드시:

- 알파벳 **한 글자**
- 숫자 / 빈 문자열 / 여러 글자 ❌
- 이미 입력한 글자 ❌
- `quit` 입력 시 게임 즉시 종료

👉 잘못된 입력은 **기회 차감 없이 다시 입력**

---

### 5️⃣ 맞았는지 / 틀렸는지 판별

```python
if userInputin word:
    underbar[i] = userInput
else:
    life -=1
```

- 맞으면 해당 알파벳 위치 전부 공개
- 틀리면 기회(`life`) 감소
- 기회가 0이 되면 해당 문제 실패

---

### 6️⃣ 점수 시스템

```python
score +=
```

- 단어 하나를 맞히면 +1점
- 실패해도 다음 문제로 진행
- 전체 문제 수 대비 점수 출력

최종 출력:

```
최종 점수 : score / total
```

---

## 💡 어려웠던 점

## 랜덤 문제 출제에서 중복 제거

```random.choice()```만 쓰면 같은 단어가 계속 나오는 문제가 있었음

이를 해결하기 위해 ```remaining_words = words.copy()``` 구조를 만들고
출제한 단어를 ```remove()```로 제거하는 방식으로 개선함

## 게임 종료 조건 설계

단어 하나의 종료 조건(성공 / 실패)과
전체 게임 종료 조건(모든 단어 소진)을 분리하는 게 처음엔 헷갈렸음

```
while '_' in underbar and life > 0
while remaining_words:
```
두 단계로 나눠서 흐름을 정리함

## 입력 검증 순서

알파벳 여부, 한 글자인지, 중복 입력 여부, quit 입력
이 조건들의 검사 순서가 UX에 영향을 준다는 걸 체감함

잘못된 입력은 기회 차감 없이 다시 입력받도록 설계함

---

## 📚 배운 점

상태를 변수로 분리해서 관리하는 중요성

```life, score, used_letters, remaining_words ```를 각각 분리하면서
게임 흐름이 훨씬 명확해짐

## 리스트를 이용한 게임 상태 관리

- underbar 리스트로 정답 공개 상태를 관리하고 ```'_' in underbar``` 로 게임 진행 여부를 판단하는 구조를 이해함

- 하드코딩 없는 구조 설계

- words 리스트만 수정하면 문제 수, 전체 게임 길이, 최종 점수가 자동으로 변경되도록 구현함

- 데이터와 로직을 분리하는 개념을 체감함

- 작은 게임도 구조가 중요하다는 것

- 단순한 게임이라도 흐름 → 상태 → 조건 → 종료를 나눠서 생각해야 유지보수가 쉬워짐

- 이후 기능 확장(난이도, 점수 가중치 등)이 가능해짐

## ✨ 한 줄 정리

간단한 콘솔 게임이지만,
랜덤 처리·상태 관리·입력 검증을 직접 구현하며
프로그램 구조를 고민하는 경험을 할 수 있었다.

## 🧪 실행 예시

- 입력 오류 → 경고 메시지 출력
- 이미 입력한 글자 → 안내 메시지 출력
- 성공 / 실패 시 이모지와 함께 결과 표시
- 남은 문제 수 & 현재 점수 실시간 확인 가능

---

## 💡 느낀 점 / 배운 점

- 랜덤 문제 출제는 **중복 관리가 핵심**
- 입력 검증 순서가 UX에 큰 영향을 준다는 걸 느낌
- 상태 변수 (`life`, `score`, `remaining_words`)를 나눠서 관리하니 흐름이 명확해짐
- 단순한 게임이라도 구조를 잡아두면 확장하기 쉬움

---

## 🔧 확장 아이디어

- 난이도 선택 (기회 수 조절)
- 노미스 보너스 점수
- 단어 카테고리별 출제
- 플레이 시간 기록
